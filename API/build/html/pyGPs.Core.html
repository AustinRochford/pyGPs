
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Core Package &mdash; pyGPs v1.2 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     'v1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pyGPs v1.2 documentation" href="index.html" />
    <link rel="up" title="pyGPs Package" href="pyGPs.html" />
    <link rel="next" title="GraphExtensions Package" href="pyGPs.GraphExtensions.html" />
    <link rel="prev" title="pyGPs Package" href="pyGPs.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyGPs.GraphExtensions.html" title="GraphExtensions Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pyGPs.html" title="pyGPs Package"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">pyGPs v1.2 documentation</a> &raquo;</li>
          <li><a href="modules.html" >pyGPs</a> &raquo;</li>
          <li><a href="pyGPs.html" accesskey="U">pyGPs Package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="core-package">
<h1>Core Package<a class="headerlink" href="#core-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">Core</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-pyGPs.Core"></span></div>
<div class="section" id="module-pyGPs.Core.cov">
<span id="cov-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">cov</span></tt> Module<a class="headerlink" href="#module-pyGPs.Core.cov" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyGPs.Core.cov.Const">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">Const</tt><big>(</big><em>log_sigma=0.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Const"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Const" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Constant kernel. hyp = [ log_sigma ]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>log_sigma</strong> &#8211; signal deviation.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.Const.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Const.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Const.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Const.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Const.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Const.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.FITCOfKernel">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">FITCOfKernel</tt><big>(</big><em>cov</em>, <em>inducingInput</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#FITCOfKernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.FITCOfKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Covariance function to be used together with the FITC approximation.
The function allows for more than one output argument and does not respect the
interface of a proper covariance function. 
Instead of outputing the full covariance, it returns cross-covariances between
the inputs x, z and the inducing inputs xu as needed by infFITC</p>
<dl class="method">
<dt id="pyGPs.Core.cov.FITCOfKernel.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#FITCOfKernel.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.FITCOfKernel.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.FITCOfKernel.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#FITCOfKernel.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.FITCOfKernel.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyGPs.Core.cov.FITCOfKernel.hyp">
<tt class="descname">hyp</tt><a class="headerlink" href="#pyGPs.Core.cov.FITCOfKernel.hyp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.Kernel">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">Kernel</tt><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is a base class of Kernel functions
there is no computation in this class, it just defines rules about a kernel class should have
each covariance function will inherit it and implement its own behaviour</p>
<dl class="method">
<dt id="pyGPs.Core.cov.Kernel.fitc">
<tt class="descname">fitc</tt><big>(</big><em>inducingInput</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Kernel.fitc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Kernel.fitc" title="Permalink to this definition">¶</a></dt>
<dd><p>Covariance function to be used together with the FITC approximation.
Setting FITC gp model will implicitly call this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an instance of FITCOfKernel</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Kernel.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="headerlink" href="#pyGPs.Core.cov.Kernel.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the specific covariance matrix according to input mode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; training data</li>
<li><strong>z</strong> &#8211; test data</li>
<li><strong>mode</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; &#8216;self_test&#8217; return self covariance matrix of test data(test by 1). 
&#8216;train&#8217; return training covariance matrix(train by train).
&#8216;cross&#8217; return cross covariance matrix between x and z(train by test)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the corresponding covariance matrix</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Kernel.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="headerlink" href="#pyGPs.Core.cov.Kernel.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute derivatives wrt. hyperparameters according to input mode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; training data</li>
<li><strong>z</strong> &#8211; test data</li>
<li><strong>mode</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; &#8216;self_test&#8217; return self derivative matrix of test data(test by 1). 
&#8216;train&#8217; return training derivative matrix(train by train).
&#8216;cross&#8217; return cross derivative matrix between x and z(train by test)</li>
<li><strong>der</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; index of hyperparameter whose derivative to be computed</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the corresponding derivative matrix</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.LINard">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">LINard</tt><big>(</big><em>D=None</em>, <em>log_ell_list=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#LINard"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.LINard" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Linear covariance function with Automatic Relevance Detemination.
hyp = log_ell_list</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>D</strong> &#8211; dimension of training data. Set if you want default ell, which is 1 for each dimension.</li>
<li><strong>log_ell_list</strong> &#8211; characteristic length scale for each dimension.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.LINard.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#LINard.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.LINard.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.LINard.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#LINard.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.LINard.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.Linear">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">Linear</tt><big>(</big><em>log_sigma=0.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Linear kernel. hyp = [ log_sigma ].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>log_sigma</strong> &#8211; signal deviation.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.Linear.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Linear.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Linear.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Linear.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Linear.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Linear.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.Matern">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">Matern</tt><big>(</big><em>log_ell=0.0</em>, <em>d=3</em>, <em>log_sigma=0.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Matern"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Matern" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Matern covariance function with nu = d/2 and isotropic distance measure. 
For d=1 the function is also known as the exponential covariance function 
or the Ornstein-Uhlenbeck covariance in 1d.
d will be rounded to 1, 3, or 5.
hyp = [ log_ell, log_sigma]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d</strong> &#8211; d is 2 times nu. Can only be 1,3 or 5.</li>
<li><strong>log_ell</strong> &#8211; characteristic length scale.</li>
<li><strong>log_sigma</strong> &#8211; signal deviation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.Matern.dfunc">
<tt class="descname">dfunc</tt><big>(</big><em>d</em>, <em>t</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Matern.dfunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Matern.dfunc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Matern.dmfunc">
<tt class="descname">dmfunc</tt><big>(</big><em>d</em>, <em>t</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Matern.dmfunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Matern.dmfunc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Matern.func">
<tt class="descname">func</tt><big>(</big><em>d</em>, <em>t</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Matern.func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Matern.func" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Matern.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Matern.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Matern.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Matern.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Matern.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Matern.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Matern.mfunc">
<tt class="descname">mfunc</tt><big>(</big><em>d</em>, <em>t</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Matern.mfunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Matern.mfunc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.Noise">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">Noise</tt><big>(</big><em>log_sigma=0.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Noise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Independent covariance function, i.e &#8220;white noise&#8221;, with specified variance.
Normally NOT used anymore since noise is now added in liklihood.
hyp = [ log_sigma ]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>log_sigma</strong> &#8211; signal deviation.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.Noise.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Noise.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Noise.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Noise.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Noise.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Noise.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.Periodic">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">Periodic</tt><big>(</big><em>log_ell=0.0</em>, <em>log_p=0.0</em>, <em>log_sigma=0.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Periodic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Stationary kernel for a smooth periodic function. 
hyp = [ log_ell, log_p, log_sigma]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>log_p</strong> &#8211; period.</li>
<li><strong>log_ell</strong> &#8211; characteristic length scale.</li>
<li><strong>log_sigma</strong> &#8211; signal deviation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.Periodic.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Periodic.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Periodic.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Periodic.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Periodic.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Periodic.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.PiecePoly">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">PiecePoly</tt><big>(</big><em>log_ell=0.0</em>, <em>v=2</em>, <em>log_sigma=0.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#PiecePoly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.PiecePoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Piecewise polynomial kernel with compact support. 
hyp = [log_ell, log_sigma]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>log_ell</strong> &#8211; characteristic length scale.</li>
<li><strong>log_sigma</strong> &#8211; signal deviation.</li>
<li><strong>v</strong> &#8211; degree v will be rounded to 0,1,2,or 3. (not treated as hyperparameter, i.e. will not be trained).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.PiecePoly.dfunc">
<tt class="descname">dfunc</tt><big>(</big><em>v</em>, <em>r</em>, <em>j</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#PiecePoly.dfunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.PiecePoly.dfunc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.PiecePoly.dpp">
<tt class="descname">dpp</tt><big>(</big><em>r</em>, <em>j</em>, <em>v</em>, <em>func</em>, <em>dfunc</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#PiecePoly.dpp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.PiecePoly.dpp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.PiecePoly.func">
<tt class="descname">func</tt><big>(</big><em>v</em>, <em>r</em>, <em>j</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#PiecePoly.func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.PiecePoly.func" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.PiecePoly.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#PiecePoly.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.PiecePoly.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.PiecePoly.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#PiecePoly.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.PiecePoly.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.PiecePoly.pp">
<tt class="descname">pp</tt><big>(</big><em>r</em>, <em>j</em>, <em>v</em>, <em>func</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#PiecePoly.pp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.PiecePoly.pp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.PiecePoly.ppmax">
<tt class="descname">ppmax</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#PiecePoly.ppmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.PiecePoly.ppmax" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.Poly">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">Poly</tt><big>(</big><em>log_c=0.0</em>, <em>d=2</em>, <em>log_sigma=0.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Poly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Polynomial covariance function. hyp = [ log_c, log_sigma ]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>log_c</strong> &#8211; inhomogeneous offset.</li>
<li><strong>log_sigma</strong> &#8211; signal deviation.</li>
<li><strong>d</strong> &#8211; degree of polynomial (not treated as hyperparameter, i.e. will not be trained).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.Poly.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Poly.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Poly.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Poly.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Poly.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Poly.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.Pre">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">Pre</tt><big>(</big><em>M1</em>, <em>M2</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Pre"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Pre" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Precomputed kernel matrix. No hyperparameters and thus nothing will be optimised.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>M1</strong> &#8211; cross covariances matrix(train+1 by test).
last row is self covariances (diagonal of test by test)</li>
<li><strong>M2</strong> &#8211; training set covariance matrix (train by train)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.Pre.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Pre.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Pre.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.Pre.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#Pre.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.Pre.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.ProductOfKernel">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">ProductOfKernel</tt><big>(</big><em>cov1</em>, <em>cov2</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#ProductOfKernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.ProductOfKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Product of two kernel function.</p>
<dl class="method">
<dt id="pyGPs.Core.cov.ProductOfKernel.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#ProductOfKernel.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.ProductOfKernel.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.ProductOfKernel.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#ProductOfKernel.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.ProductOfKernel.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyGPs.Core.cov.ProductOfKernel.hyp">
<tt class="descname">hyp</tt><a class="headerlink" href="#pyGPs.Core.cov.ProductOfKernel.hyp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.RBF">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">RBF</tt><big>(</big><em>log_ell=0.0</em>, <em>log_sigma=0.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RBF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RBF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Squared Exponential kernel with isotropic distance measure. hyp = [log_ell, log_sigma]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>log_ell</strong> &#8211; characteristic length scale.</li>
<li><strong>log_sigma</strong> &#8211; signal deviation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.RBF.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RBF.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RBF.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.RBF.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RBF.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RBF.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.RBFard">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">RBFard</tt><big>(</big><em>D=None</em>, <em>log_ell_list=None</em>, <em>log_sigma=0.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RBFard"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RBFard" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Squared Exponential kernel with Automatic Relevance Determination.
hyp = log_ell_list + [log_sigma]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>D</strong> &#8211; dimension of pattern. set if you want default ell, which is 1 for each dimension.</li>
<li><strong>log_ell_list</strong> &#8211; characteristic length scale for each dimension.</li>
<li><strong>log_sigma</strong> &#8211; signal deviation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.RBFard.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RBFard.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RBFard.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.RBFard.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RBFard.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RBFard.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.RBFunit">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">RBFunit</tt><big>(</big><em>log_ell=0.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RBFunit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RBFunit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Squared Exponential kernel with isotropic distance measure with unit magnitude.
i.e signal variance is always 1. hyp = [ log_ell ]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>log_ell</strong> &#8211; characteristic length scale.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.RBFunit.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RBFunit.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RBFunit.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.RBFunit.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RBFunit.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RBFunit.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.RQ">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">RQ</tt><big>(</big><em>log_ell=0.0</em>, <em>log_sigma=0.0</em>, <em>log_alpha=0.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RQ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Rational Quadratic covariance function with isotropic distance measure.
hyp = [ log_ell, log_sigma, log_alpha ]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>log_ell</strong> &#8211; characteristic length scale.</li>
<li><strong>log_sigma</strong> &#8211; signal deviation.</li>
<li><strong>log_alpha</strong> &#8211; shape parameter for the RQ covariance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.RQ.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RQ.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RQ.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.RQ.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RQ.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RQ.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.RQard">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">RQard</tt><big>(</big><em>D=None</em>, <em>log_ell_list=None</em>, <em>log_sigma=0.0</em>, <em>log_alpha=0.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RQard"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RQard" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Rational Quadratic covariance function with Automatic Relevance Detemination
(ARD) distance measure.
hyp = log_ell_list + [ log_sigma, log_alpha ]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>D</strong> &#8211; dimension of pattern. set if you want default ell, which is 0.5 for each dimension.</li>
<li><strong>log_ell_list</strong> &#8211; characteristic length scale for each dimension.</li>
<li><strong>log_sigma</strong> &#8211; signal deviation.</li>
<li><strong>log_alpha</strong> &#8211; shape parameter for the RQ covariance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.cov.RQard.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RQard.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RQard.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.RQard.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#RQard.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.RQard.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.ScaleOfKernel">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">ScaleOfKernel</tt><big>(</big><em>cov</em>, <em>scalar</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#ScaleOfKernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.ScaleOfKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Scale of a kernel function.</p>
<dl class="method">
<dt id="pyGPs.Core.cov.ScaleOfKernel.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#ScaleOfKernel.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.ScaleOfKernel.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.ScaleOfKernel.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#ScaleOfKernel.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.ScaleOfKernel.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyGPs.Core.cov.ScaleOfKernel.hyp">
<tt class="descname">hyp</tt><a class="headerlink" href="#pyGPs.Core.cov.ScaleOfKernel.hyp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.cov.SumOfKernel">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.cov.</tt><tt class="descname">SumOfKernel</tt><big>(</big><em>cov1</em>, <em>cov2</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#SumOfKernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.SumOfKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.cov.Kernel" title="pyGPs.Core.cov.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.cov.Kernel</span></tt></a></p>
<p>Sum of two kernel function.</p>
<dl class="method">
<dt id="pyGPs.Core.cov.SumOfKernel.getCovMatrix">
<tt class="descname">getCovMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#SumOfKernel.getCovMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.SumOfKernel.getCovMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.cov.SumOfKernel.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>z=None</em>, <em>mode=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/cov.html#SumOfKernel.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.cov.SumOfKernel.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyGPs.Core.cov.SumOfKernel.hyp">
<tt class="descname">hyp</tt><a class="headerlink" href="#pyGPs.Core.cov.SumOfKernel.hyp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyGPs.Core.gp">
<span id="gp-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">gp</span></tt> Module<a class="headerlink" href="#module-pyGPs.Core.gp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyGPs.Core.gp.GP">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.gp.</tt><tt class="descname">GP</tt><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for GP model</p>
<dl class="method">
<dt id="pyGPs.Core.gp.GP.fit">
<tt class="descname">fit</tt><big>(</big><em>x=None</em>, <em>y=None</em>, <em>der=True</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the training data. Update negative log marginal likelihood(nlZ), 
partial derivatives of nlZ w.r.t. each hyperparameter(dnlZ),
and struct representation of the (approximate) posterior(post), 
which consists of post.alpha, post.L, post.sW.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GP.optimize">
<tt class="descname">optimize</tt><big>(</big><em>x=None</em>, <em>y=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP.optimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Train optimal hyperparameters based on training data,
adjust new hyperparameters to all mean/cov/lik functions</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GP.plotData_1d">
<tt class="descname">plotData_1d</tt><big>(</big><em>axisvals=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP.plotData_1d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP.plotData_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 1d (toy) data.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GP.plotData_2d">
<tt class="descname">plotData_2d</tt><big>(</big><em>x1</em>, <em>x2</em>, <em>t1</em>, <em>t2</em>, <em>p1</em>, <em>p2</em>, <em>axisvals=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP.plotData_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP.plotData_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 2d (toy) data.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GP.predict">
<tt class="descname">predict</tt><big>(</big><em>xs</em>, <em>ys=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Prediction according to given inputs.
Get predictive output means(ym), 
predictive output variances(ys2),
predictive latent means(fm),
predictive latent variances(fs2),
log predictive probabilities(lp).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xs</strong> &#8211; test input</li>
<li><strong>ys</strong> &#8211; test target(optional)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ym, ys2, fm, fs2, lp</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GP.predict_with_posterior">
<tt class="descname">predict_with_posterior</tt><big>(</big><em>post</em>, <em>xs</em>, <em>ys=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP.predict_with_posterior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP.predict_with_posterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Prediction with provided posterior
(i.e. you already have the posterior and thus don&#8217;t need fitting/training phases)
Get predictive output means(ym), 
predictive output variances(ys2),
predictive latent means(fm),
predictive latent variances(fs2),
log predictive probabilities(lp).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>post</strong> &#8211; struct representation of posterior</li>
<li><strong>xs</strong> &#8211; test input</li>
<li><strong>ys</strong> &#8211; test target(optional)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ym, ys2, fm, fs2, lp</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GP.setData">
<tt class="descname">setData</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP.setData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP.setData" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass training data and traning labels to model.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GP.setOptimizer">
<tt class="descname">setOptimizer</tt><big>(</big><em>method</em>, <em>num_restarts=None</em>, <em>min_threshold=None</em>, <em>meanRange=None</em>, <em>covRange=None</em>, <em>likRange=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP.setOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP.setOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is used to sepecify optimization configuration. By default, gp uses a single run &#8220;minimize&#8221;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>method</strong> &#8211; <p>Optimization methods. Possible values are:</p>
<p>&#8220;Minimize&#8221;   -&gt; minimize by Carl Rasmussen (python implementation of &#8220;minimize&#8221; in GPML)</p>
<p>&#8220;CG&#8221;         -&gt; conjugent gradient</p>
<p>&#8220;BFGS&#8221;       -&gt; quasi-Newton method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS)</p>
<p>&#8220;SCG&#8221;        -&gt; scaled conjugent gradient (faster than CG)</p>
</li>
<li><strong>num_restarts</strong> &#8211; Set if you want to run mulitiple times of optimization with different initial guess. 
It specifys the maximum number of runs/restarts/trials.</li>
<li><strong>min_threshold</strong> &#8211; Set if you want to run mulitiple times of optimization with different initial guess. 
It specifys the threshold of objective function value. Stop optimization when this value is reached.</li>
<li><strong>meanRange</strong> &#8211; <p>The range of initial guess for mean hyperparameters. 
e.g. meanRange = [(-2,2), (-5,5), (0,1)].
Each tuple specifys the range (low, high) of this hyperparameter,
This is only the range of initial guess, during optimization process, optimal hyperparameters may go out of this range.</p>
<p>(-5,5) for each hyperparameter by default.</p>
</li>
<li><strong>covRange</strong> &#8211; The range of initial guess for kernel hyperparameters. Usage see meanRange</li>
<li><strong>likRange</strong> &#8211; The range of initial guess for likelihood hyperparameters. Usage see meanRange</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GP.setPrior">
<tt class="descname">setPrior</tt><big>(</big><em>mean=None</em>, <em>kernel=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP.setPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP.setPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Set prior mean and cov</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.gp.GPC">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.gp.</tt><tt class="descname">GPC</tt><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.gp.GP" title="pyGPs.Core.gp.GP"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.gp.GP</span></tt></a></p>
<p>Gaussian Process Classification</p>
<dl class="method">
<dt id="pyGPs.Core.gp.GPC.plot">
<tt class="descname">plot</tt><big>(</big><em>x1</em>, <em>x2</em>, <em>t1</em>, <em>t2</em>, <em>axisvals=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPC.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPC.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 2d gp classification.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPC.setOptimizer">
<tt class="descname">setOptimizer</tt><big>(</big><em>method</em>, <em>num_restarts=None</em>, <em>min_threshold=None</em>, <em>meanRange=None</em>, <em>covRange=None</em>, <em>likRange=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPC.setOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPC.setOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set Optimizer. See base class.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPC.useInference">
<tt class="descname">useInference</tt><big>(</big><em>newInf</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPC.useInference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPC.useInference" title="Permalink to this definition">¶</a></dt>
<dd><p>Use another inference techinique other than default EP inference.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newInf</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; &#8216;Laplace&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPC.useLikelihood">
<tt class="descname">useLikelihood</tt><big>(</big><em>newLik</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPC.useLikelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPC.useLikelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Use another likelihood function other than default Erf inference.
(Not used in this version)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newLik</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; &#8216;Logistic&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.gp.GPC_FITC">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.gp.</tt><tt class="descname">GPC_FITC</tt><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPC_FITC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPC_FITC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.gp.GP_FITC" title="pyGPs.Core.gp.GP_FITC"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.gp.GP_FITC</span></tt></a></p>
<p>Gaussian Process Classification FITC</p>
<dl class="method">
<dt id="pyGPs.Core.gp.GPC_FITC.plot">
<tt class="descname">plot</tt><big>(</big><em>x1</em>, <em>x2</em>, <em>t1</em>, <em>t2</em>, <em>axisvals=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPC_FITC.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPC_FITC.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 2d GP FITC classification.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPC_FITC.setOptimizer">
<tt class="descname">setOptimizer</tt><big>(</big><em>method</em>, <em>num_restarts=None</em>, <em>min_threshold=None</em>, <em>meanRange=None</em>, <em>covRange=None</em>, <em>likRange=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPC_FITC.setOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPC_FITC.setOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set optimizer. See base class.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPC_FITC.useInference">
<tt class="descname">useInference</tt><big>(</big><em>newInf</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPC_FITC.useInference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPC_FITC.useInference" title="Permalink to this definition">¶</a></dt>
<dd><p>Use another inference techinique other than default exact inference.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newInf</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; &#8216;Laplace&#8217; or &#8216;EP&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPC_FITC.useLikelihood">
<tt class="descname">useLikelihood</tt><big>(</big><em>newLik</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPC_FITC.useLikelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPC_FITC.useLikelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Use another inference techinique other than default Erf likelihood.
(Not used in this version)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newLik</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; &#8216;Logistic&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.gp.GPMC">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.gp.</tt><tt class="descname">GPMC</tt><big>(</big><em>n_class</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPMC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is a one vs. one classification wrapper for GPC</p>
<dl class="method">
<dt id="pyGPs.Core.gp.GPMC.createBinaryClass">
<tt class="descname">createBinaryClass</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPMC.createBinaryClass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPMC.createBinaryClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Create dataset x(data) and y(label) which only contains class i and j.
Relabel class i to +1 and class j to -1</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPMC.fitAndPredict">
<tt class="descname">fitAndPredict</tt><big>(</big><em>xs</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPMC.fitAndPredict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPMC.fitAndPredict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fitting model and prediction.
predictive_vote is a matrix where
row i is each test point i
column j is the probability for being class j</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">predictive_vote</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPMC.optimizeAndPredict">
<tt class="descname">optimizeAndPredict</tt><big>(</big><em>xs</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPMC.optimizeAndPredict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPMC.optimizeAndPredict" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimizing model and prediction.
predictive_vote is a matrix where
row i is each test point i
column j is the probability for being class j</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">predictive_vote</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPMC.setData">
<tt class="descname">setData</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPMC.setData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPMC.setData" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data for multi-class model</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPMC.setPrior">
<tt class="descname">setPrior</tt><big>(</big><em>mean=None</em>, <em>kernel=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPMC.setPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPMC.setPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>set prior mean function and covariance function</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPMC.useInference">
<tt class="descname">useInference</tt><big>(</big><em>newInf</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPMC.useInference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPMC.useInference" title="Permalink to this definition">¶</a></dt>
<dd><p>Use another inference techinique other than default EP inference.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPMC.useLikelihood">
<tt class="descname">useLikelihood</tt><big>(</big><em>newLik</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPMC.useLikelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPMC.useLikelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Use another likelihood function other than default Erf inference.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.gp.GPR">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.gp.</tt><tt class="descname">GPR</tt><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.gp.GP" title="pyGPs.Core.gp.GP"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.gp.GP</span></tt></a></p>
<p>Gaussian Process Regression</p>
<dl class="method">
<dt id="pyGPs.Core.gp.GPR.plot">
<tt class="descname">plot</tt><big>(</big><em>axisvals=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPR.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPR.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 1d GP regression.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPR.setNoise">
<tt class="descname">setNoise</tt><big>(</big><em>log_sigma</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPR.setNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPR.setNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Set noise variance other than default</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPR.setOptimizer">
<tt class="descname">setOptimizer</tt><big>(</big><em>method</em>, <em>num_restarts=None</em>, <em>min_threshold=None</em>, <em>meanRange=None</em>, <em>covRange=None</em>, <em>likRange=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPR.setOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPR.setOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set Optimizer. See base class.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPR.useInference">
<tt class="descname">useInference</tt><big>(</big><em>newInf</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPR.useInference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPR.useInference" title="Permalink to this definition">¶</a></dt>
<dd><p>Use another inference techinique other than default exact inference.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newInf</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; &#8216;Laplace&#8217; or &#8216;EP&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPR.useLikelihood">
<tt class="descname">useLikelihood</tt><big>(</big><em>newLik</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPR.useLikelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPR.useLikelihood" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.gp.GPR_FITC">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.gp.</tt><tt class="descname">GPR_FITC</tt><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPR_FITC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPR_FITC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.gp.GP_FITC" title="pyGPs.Core.gp.GP_FITC"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.gp.GP_FITC</span></tt></a></p>
<p>Gaussian Process Regression FITC</p>
<dl class="method">
<dt id="pyGPs.Core.gp.GPR_FITC.plot">
<tt class="descname">plot</tt><big>(</big><em>axisvals=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPR_FITC.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPR_FITC.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 1d GP FITC regression.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPR_FITC.setNoise">
<tt class="descname">setNoise</tt><big>(</big><em>log_sigma</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPR_FITC.setNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPR_FITC.setNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Set noise variance other than default value</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPR_FITC.setOptimizer">
<tt class="descname">setOptimizer</tt><big>(</big><em>method</em>, <em>num_restarts=None</em>, <em>min_threshold=None</em>, <em>meanRange=None</em>, <em>covRange=None</em>, <em>likRange=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPR_FITC.setOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPR_FITC.setOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set Optimizer. See base class.</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPR_FITC.useInference">
<tt class="descname">useInference</tt><big>(</big><em>newInf</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPR_FITC.useInference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPR_FITC.useInference" title="Permalink to this definition">¶</a></dt>
<dd><p>Use another inference techinique other than default exact inference.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newInf</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; &#8216;Laplace&#8217; or &#8216;EP&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GPR_FITC.useLikelihood">
<tt class="descname">useLikelihood</tt><big>(</big><em>newLik</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GPR_FITC.useLikelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GPR_FITC.useLikelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Use another inference techinique other than default Gaussian likelihood.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newLik</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; &#8216;Laplace&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.gp.GP_FITC">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.gp.</tt><tt class="descname">GP_FITC</tt><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP_FITC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP_FITC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.gp.GP" title="pyGPs.Core.gp.GP"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.gp.GP</span></tt></a></p>
<p>FITC GP base class</p>
<dl class="method">
<dt id="pyGPs.Core.gp.GP_FITC.setData">
<tt class="descname">setData</tt><big>(</big><em>x</em>, <em>y</em>, <em>value_per_axis=5</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP_FITC.setData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP_FITC.setData" title="Permalink to this definition">¶</a></dt>
<dd><p>Set training data and derive deault inducing_points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; training data</li>
<li><strong>y</strong> &#8211; training target</li>
<li><strong>value_per_axis</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; number of value in each dimension</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>when using a uni-distant default inducing points</p>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.gp.GP_FITC.setPrior">
<tt class="descname">setPrior</tt><big>(</big><em>mean=None</em>, <em>kernel=None</em>, <em>inducing_points=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/gp.html#GP_FITC.setPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.gp.GP_FITC.setPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Set GP prior and inducing points</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyGPs.Core.inf">
<span id="inf-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">inf</span></tt> Module<a class="headerlink" href="#module-pyGPs.Core.inf" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyGPs.Core.inf.EP">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.inf.</tt><tt class="descname">EP</tt><a class="reference internal" href="_modules/pyGPs/Core/inf.html#EP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.EP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.inf.Inference" title="pyGPs.Core.inf.Inference"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.inf.Inference</span></tt></a></p>
<p>Expectation Propagation approximation to the posterior Gaussian Process.</p>
<dl class="method">
<dt id="pyGPs.Core.inf.EP.proceed">
<tt class="descname">proceed</tt><big>(</big><em>meanfunc</em>, <em>covfunc</em>, <em>likfunc</em>, <em>x</em>, <em>y</em>, <em>nargout=1</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/inf.html#EP.proceed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.EP.proceed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.inf.Exact">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.inf.</tt><tt class="descname">Exact</tt><a class="reference internal" href="_modules/pyGPs/Core/inf.html#Exact"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.Exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.inf.Inference" title="pyGPs.Core.inf.Inference"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.inf.Inference</span></tt></a></p>
<p>Exact inference for a GP with Gaussian likelihood. Compute a parametrization
of the posterior, the negative log marginal likelihood and its derivatives
w.r.t. the hyperparameters.</p>
<dl class="method">
<dt id="pyGPs.Core.inf.Exact.proceed">
<tt class="descname">proceed</tt><big>(</big><em>meanfunc</em>, <em>covfunc</em>, <em>likfunc</em>, <em>x</em>, <em>y</em>, <em>nargout=1</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/inf.html#Exact.proceed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.Exact.proceed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.inf.FITC_EP">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.inf.</tt><tt class="descname">FITC_EP</tt><a class="reference internal" href="_modules/pyGPs/Core/inf.html#FITC_EP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.FITC_EP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.inf.Inference" title="pyGPs.Core.inf.Inference"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.inf.Inference</span></tt></a></p>
<p>FITC-EP approximation to the posterior Gaussian process. The function is
equivalent to infEP with the covariance function:
Kt = Q + G; G = diag(g); g = diag(K-Q);  Q = Ku&#8217; * inv(Kuu + snu2 * eye(nu)) * Ku;
where Ku and Kuu are covariances w.r.t. to inducing inputs xu and
snu2 = sn2/1e6 is the noise of the inducing inputs. We fixed the standard
deviation of the inducing inputs snu to be a one per mil of the measurement 
noise&#8217;s standard deviation sn. In case of a likelihood without noise
parameter sn2, we simply use snu2 = 1e-6.
For details, see The Generalized FITC Approximation, Andrew Naish-Guzman and
Sean Holden, NIPS, 2007.</p>
<dl class="method">
<dt id="pyGPs.Core.inf.FITC_EP.proceed">
<tt class="descname">proceed</tt><big>(</big><em>meanfunc</em>, <em>covfunc</em>, <em>likfunc</em>, <em>x</em>, <em>y</em>, <em>nargout=1</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/inf.html#FITC_EP.proceed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.FITC_EP.proceed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.inf.FITC_Exact">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.inf.</tt><tt class="descname">FITC_Exact</tt><a class="reference internal" href="_modules/pyGPs/Core/inf.html#FITC_Exact"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.FITC_Exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.inf.Inference" title="pyGPs.Core.inf.Inference"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.inf.Inference</span></tt></a></p>
<p>FITC approximation to the posterior Gaussian process. The function is
equivalent to infExact with the covariance function:
Kt = Q + G; G = diag(g); g = diag(K-Q);  Q = Ku&#8217; * inv(Quu) * Ku; 
where Ku and Kuu are covariances w.r.t. to inducing inputs xu, snu2 = sn2/1e6
is the noise of the inducing inputs and Quu = Kuu + snu2*eye(nu).</p>
<dl class="method">
<dt id="pyGPs.Core.inf.FITC_Exact.proceed">
<tt class="descname">proceed</tt><big>(</big><em>meanfunc</em>, <em>covfunc</em>, <em>likfunc</em>, <em>x</em>, <em>y</em>, <em>nargout=1</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/inf.html#FITC_Exact.proceed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.FITC_Exact.proceed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.inf.FITC_Laplace">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.inf.</tt><tt class="descname">FITC_Laplace</tt><a class="reference internal" href="_modules/pyGPs/Core/inf.html#FITC_Laplace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.FITC_Laplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.inf.Inference" title="pyGPs.Core.inf.Inference"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.inf.Inference</span></tt></a></p>
<p>FITC-Laplace approximation to the posterior Gaussian process. The function is
equivalent to infLaplace with the covariance function:
Kt = Q + G; G = diag(g); g = diag(K-Q);  Q = Ku&#8217; * inv(Kuu + snu2 * eye(nu)) * Ku;
where Ku and Kuu are covariances w.r.t. to inducing inputs xu and
snu2 = sn2/1e6 is the noise of the inducing inputs. We fixed the standard
deviation of the inducing inputs snu to be a one per mil of the measurement 
noise&#8217;s standard deviation sn. In case of a likelihood without noise
parameter sn2, we simply use snu2 = 1e-6.</p>
<dl class="method">
<dt id="pyGPs.Core.inf.FITC_Laplace.proceed">
<tt class="descname">proceed</tt><big>(</big><em>meanfunc</em>, <em>covfunc</em>, <em>likfunc</em>, <em>x</em>, <em>y</em>, <em>nargout=1</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/inf.html#FITC_Laplace.proceed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.FITC_Laplace.proceed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.inf.Inference">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.inf.</tt><tt class="descname">Inference</tt><a class="reference internal" href="_modules/pyGPs/Core/inf.html#Inference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.Inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for inference. Defined several tool methods in it.</p>
<dl class="method">
<dt id="pyGPs.Core.inf.Inference.proceed">
<tt class="descname">proceed</tt><big>(</big><em>meanfunc</em>, <em>covfunc</em>, <em>likfunc</em>, <em>x</em>, <em>y</em>, <em>nargout=1</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/inf.html#Inference.proceed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.Inference.proceed" title="Permalink to this definition">¶</a></dt>
<dd><p>Inference computation based on inputs.
post, nlZ, dnlZ = inf.proceed(mean, cov, lik, x, y)</p>
<blockquote>
<div><div class="line-block">
<div class="line">INPUT:</div>
<div class="line">cov: name of the covariance function (see covFunctions.m)</div>
<div class="line">lik: name of the likelihood function (see likFunctions.m)</div>
<div class="line">x: n by D matrix of training inputs </div>
<div class="line">y: 1d array (of size n) of targets</div>
</div>
<div class="line-block">
<div class="line">OUTPUT:</div>
<div class="line">post(postStruct): struct representation of the (approximate) posterior containing: </div>
<div class="line">nlZ: returned value of the negative log marginal likelihood</div>
<div class="line">dnlZ(dnlZStruct): struct representation for derivatives of the negative log marginal likelihood</div>
<div class="line">w.r.t. each hyperparameter.</div>
</div>
</div></blockquote>
<p>Usually, the approximate posterior to be returned admits the form: 
N(m=K*alpha, V=inv(inv(K)+W)), where alpha is a vector and W is diagonal;
if not, then L contains instead -inv(K+inv(W)), and sW is unused.</p>
<p>For more information on the individual approximation methods and their
implementations, see the respective inference function below. See also gp.py</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>meanfunc</strong> &#8211; mean function</li>
<li><strong>covfunc</strong> &#8211; covariance function</li>
<li><strong>likfunc</strong> &#8211; likelihood function</li>
<li><strong>x</strong> &#8211; training data</li>
<li><strong>y</strong> &#8211; training labels</li>
<li><strong>nargout</strong> &#8211; specify the number of output(1,2 or 3)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">posterior, negative-log-marginal-likelihood, derivative for negative-log-marginal-likelihood-likelihood</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.inf.Laplace">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.inf.</tt><tt class="descname">Laplace</tt><a class="reference internal" href="_modules/pyGPs/Core/inf.html#Laplace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.Laplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.inf.Inference" title="pyGPs.Core.inf.Inference"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.inf.Inference</span></tt></a></p>
<p>Laplace&#8217;s Approximation to the posterior Gaussian process.</p>
<dl class="method">
<dt id="pyGPs.Core.inf.Laplace.proceed">
<tt class="descname">proceed</tt><big>(</big><em>meanfunc</em>, <em>covfunc</em>, <em>likfunc</em>, <em>x</em>, <em>y</em>, <em>nargout=1</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/inf.html#Laplace.proceed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.Laplace.proceed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.inf.dnlZStruct">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.inf.</tt><tt class="descname">dnlZStruct</tt><big>(</big><em>m</em>, <em>c</em>, <em>l</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/inf.html#dnlZStruct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.dnlZStruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Data structure for the derivatives of mean, cov and lik functions.</p>
<p><a href="#id2"><span class="problematic" id="id3">|</span></a>dnlZ.mean: list of derivatives for each hyperparameters in mean function
<a href="#id4"><span class="problematic" id="id5">|</span></a>dnlZ.cov: list of derivatives for each hyperparameters in covariance function
<a href="#id6"><span class="problematic" id="id7">|</span></a>dnlZ.lik: list of derivatives for each hyperparameters in likelihood function</p>
</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.inf.postStruct">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.inf.</tt><tt class="descname">postStruct</tt><a class="reference internal" href="_modules/pyGPs/Core/inf.html#postStruct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.inf.postStruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Data structure for posterior</p>
<div class="line-block">
<div class="line">post.alpha: 1d array containing inv(K)*m, </div>
<div class="line">where K is the prior covariance matrix and m the approx posterior mean</div>
<div class="line">post.sW: 1d array containing diagonal of sqrt(W)</div>
<div class="line">the approximate posterior covariance matrix is inv(inv(K)+W)</div>
<div class="line">post.L : 2d array, L = chol(sW*K*sW+identity(n))</div>
</div>
</dd></dl>

</div>
<div class="section" id="module-pyGPs.Core.lik">
<span id="lik-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">lik</span></tt> Module<a class="headerlink" href="#module-pyGPs.Core.lik" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyGPs.Core.lik.Erf">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.lik.</tt><tt class="descname">Erf</tt><a class="reference internal" href="_modules/pyGPs/Core/lik.html#Erf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.lik.Erf" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.lik.Likelihood" title="pyGPs.Core.lik.Likelihood"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.lik.Likelihood</span></tt></a></p>
<p>Error function or cumulative Gaussian likelihood function for binary
classification or probit regression.</p>
<p>Erf(t)=\frac{1}{2}(1+erf(\frac{t}{\sqrt{2}}))=normcdf(t)</p>
<dl class="method">
<dt id="pyGPs.Core.lik.Erf.cumGauss">
<tt class="descname">cumGauss</tt><big>(</big><em>y=None</em>, <em>f=None</em>, <em>nargout=1</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/lik.html#Erf.cumGauss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.lik.Erf.cumGauss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.lik.Erf.gauOverCumGauss">
<tt class="descname">gauOverCumGauss</tt><big>(</big><em>f</em>, <em>p</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/lik.html#Erf.gauOverCumGauss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.lik.Erf.gauOverCumGauss" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.lik.Erf.logphi">
<tt class="descname">logphi</tt><big>(</big><em>z</em>, <em>p</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/lik.html#Erf.logphi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.lik.Erf.logphi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.lik.Erf.proceed">
<tt class="descname">proceed</tt><big>(</big><em>y=None</em>, <em>mu=None</em>, <em>s2=None</em>, <em>inffunc=None</em>, <em>der=None</em>, <em>nargout=1</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/lik.html#Erf.proceed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.lik.Erf.proceed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.lik.Gauss">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.lik.</tt><tt class="descname">Gauss</tt><big>(</big><em>log_sigma=-2.3025850929940455</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/lik.html#Gauss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.lik.Gauss" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.lik.Likelihood" title="pyGPs.Core.lik.Likelihood"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.lik.Likelihood</span></tt></a></p>
<p>Gaussian likelihood function for regression.</p>
<p>Gauss(t)=\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(t-y)^2}{2\sigma^2}},
where y is the mean and \sigma is the standard deviation.</p>
<p>hyp = [ log_sigma ]</p>
<dl class="method">
<dt id="pyGPs.Core.lik.Gauss.proceed">
<tt class="descname">proceed</tt><big>(</big><em>y=None</em>, <em>mu=None</em>, <em>s2=None</em>, <em>inffunc=None</em>, <em>der=None</em>, <em>nargout=1</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/lik.html#Gauss.proceed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.lik.Gauss.proceed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.lik.Laplace">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.lik.</tt><tt class="descname">Laplace</tt><big>(</big><em>log_sigma=-2.3025850929940455</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/lik.html#Laplace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.lik.Laplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.lik.Likelihood" title="pyGPs.Core.lik.Likelihood"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.lik.Likelihood</span></tt></a></p>
<p>Laplacian likelihood function for regression. ONLY works with EP inference!</p>
<p>Laplace(t) = \frac{1}{2b}e^{-\frac{|t-y|}{b}} where b=\frac{\sigma}{\sqrt{2}},
y is the mean and \sigma is the standard deviation.</p>
<p>hyp = [ log_sigma ]</p>
<dl class="method">
<dt id="pyGPs.Core.lik.Laplace.proceed">
<tt class="descname">proceed</tt><big>(</big><em>y=None</em>, <em>mu=None</em>, <em>s2=None</em>, <em>inffunc=None</em>, <em>der=None</em>, <em>nargout=1</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/lik.html#Laplace.proceed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.lik.Laplace.proceed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.lik.Likelihood">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.lik.</tt><tt class="descname">Likelihood</tt><a class="reference internal" href="_modules/pyGPs/Core/lik.html#Likelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.lik.Likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base function for Likelihood function</p>
<dl class="method">
<dt id="pyGPs.Core.lik.Likelihood.proceed">
<tt class="descname">proceed</tt><big>(</big><em>y=None</em>, <em>mu=None</em>, <em>s2=None</em>, <em>inffunc=None</em>, <em>der=None</em>, <em>nargout=1</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/lik.html#Likelihood.proceed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.lik.Likelihood.proceed" title="Permalink to this definition">¶</a></dt>
<dd><p>The likelihood functions have two possible modes, the mode being selected
as follows (where &#8220;lik&#8221; stands for &#8220;proceed&#8221; method for any likelihood function):</p>
<ol class="arabic simple">
<li>With two or three input arguments:                       [PREDICTION MODE]</li>
</ol>
<blockquote>
<div><p>lp = lik(y, mu) OR lp, ymu, ys2 = lik(y, mu, s2)</p>
<blockquote>
<div><p>This allows to evaluate the predictive distribution. Let p(y_*|f_*) be the
likelihood of a test point and N(f_*|mu,s2) an approximation to the posterior
marginal p(f_*|x_*,x,y) as returned by an inference method. The predictive
distribution p(y_*|x_*,x,y) is approximated by:
q(y_*) = int N(f_*|mu,s2) p(y_*|f_*) df_*</p>
<p>lp = log( q(y) ) for a particular value of y, if s2 is [] or 0, this
corresponds to log( p(y|mu) ).</p>
<p>ymu and ys2 are the mean and variance of the predictive marginal q(y)
note that these two numbers do not depend on a particular 
value of y.
All vectors have the same size.</p>
</div></blockquote>
</div></blockquote>
<ol class="arabic simple" start="2">
<li>With four or five input arguments, the fouth being an object of class &#8220;Inference&#8221; [INFERENCE MODE]</li>
</ol>
<blockquote>
<div><p>lik(y, mu, s2, inf) OR lik(y, mu, s2, inf, i)</p>
<p>There are two cases for inf, namely a) infLaplace, b) infEP 
The last input i, refers to derivatives w.r.t. the ith hyperparameter.</p>
<div class="line-block">
<div class="line">a1) </div>
<div class="line">lp,dlp,d2lp,d3lp = lik(y, f, [], &#8216;infLaplace&#8217;). </div>
<div class="line">lp, dlp, d2lp and d3lp correspond to derivatives of the log likelihood. </div>
<div class="line">log(p(y|f)) w.r.t. to the latent location f.</div>
<div class="line">lp = log( p(y|f) ) </div>
<div class="line">dlp = d log( p(y|f) ) / df </div>
<div class="line">d2lp = d^2 log( p(y|f) ) / df^2</div>
<div class="line">d3lp = d^3 log( p(y|f) ) / df^3 </div>
</div>
<div class="line-block">
<div class="line">a2)</div>
<div class="line">lp_dhyp,dlp_dhyp,d2lp_dhyp = lik(y, f, [], &#8216;infLaplace&#8217;, i) </div>
<div class="line">returns derivatives w.r.t. to the ith hyperparameter </div>
<div class="line">lp_dhyp = d log( p(y|f) ) / (dhyp_i) </div>
<div class="line">dlp_dhyp = d^2 log( p(y|f) ) / (df   dhyp_i) </div>
<div class="line">d2lp_dhyp = d^3 log( p(y|f) ) / (df^2 dhyp_i) </div>
</div>
<div class="line-block">
<div class="line">b1)</div>
<div class="line">lZ,dlZ,d2lZ = lik(y, mu, s2, &#8216;infEP&#8217;) </div>
<div class="line">let Z = int p(y|f) N(f|mu,s2) df then </div>
<div class="line">lZ = log(Z) </div>
<div class="line">dlZ = d log(Z) / dmu </div>
<div class="line">d2lZ = d^2 log(Z) / dmu^2 </div>
</div>
<div class="line-block">
<div class="line">b2)</div>
<div class="line">dlZhyp = lik(y, mu, s2, &#8216;infEP&#8217;, i)</div>
<div class="line">returns derivatives w.r.t. to the ith hyperparameter </div>
<div class="line">dlZhyp = d log(Z) / dhyp_i </div>
</div>
</div></blockquote>
<p>Cumulative likelihoods are designed for binary classification. Therefore, they
only look at the sign of the targets y; zero values are treated as +1.</p>
<dl class="docutils">
<dt>Some examples for valid likelihood functions:</dt>
<dd><div class="first last line-block">
<div class="line">lik = likGauss([0.1])</div>
<div class="line">lik = likErf()</div>
</div>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyGPs.Core.mean">
<span id="mean-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">mean</span></tt> Module<a class="headerlink" href="#module-pyGPs.Core.mean" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyGPs.Core.mean.Const">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.mean.</tt><tt class="descname">Const</tt><big>(</big><em>c=5.0</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#Const"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.Const" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.mean.Mean" title="pyGPs.Core.mean.Mean"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.mean.Mean</span></tt></a></p>
<p>Constant mean function. hyp = [c]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>c</strong> &#8211; constant value for mean</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.mean.Const.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#Const.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.Const.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.mean.Const.getMean">
<tt class="descname">getMean</tt><big>(</big><em>x=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#Const.getMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.Const.getMean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.mean.Linear">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.mean.</tt><tt class="descname">Linear</tt><big>(</big><em>D=None</em>, <em>alpha_list=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#Linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.Linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.mean.Mean" title="pyGPs.Core.mean.Mean"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.mean.Mean</span></tt></a></p>
<p>Linear mean function. self.hyp = alpha_list</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>D</strong> &#8211; dimension of training data. Set if you want default alpha, which is 0.5 for each dimension.</td>
</tr>
<tr class="field-even field"><th class="field-name">Alpha_list :</th><td class="field-body">scalar alpha for each dimension</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyGPs.Core.mean.Linear.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#Linear.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.Linear.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.mean.Linear.getMean">
<tt class="descname">getMean</tt><big>(</big><em>x=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#Linear.getMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.Linear.getMean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.mean.Mean">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.mean.</tt><tt class="descname">Mean</tt><a class="reference internal" href="_modules/pyGPs/Core/mean.html#Mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.Mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The base function for mean function</p>
<dl class="method">
<dt id="pyGPs.Core.mean.Mean.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>der=None</em><big>)</big><a class="headerlink" href="#pyGPs.Core.mean.Mean.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute derivatives wrt. hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; training data</li>
<li><strong>der</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; index of hyperparameter whose derivative to be computed</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the corresponding derivative matrix</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyGPs.Core.mean.Mean.getMean">
<tt class="descname">getMean</tt><big>(</big><em>x=None</em><big>)</big><a class="headerlink" href="#pyGPs.Core.mean.Mean.getMean" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mean vector.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.mean.One">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.mean.</tt><tt class="descname">One</tt><a class="reference internal" href="_modules/pyGPs/Core/mean.html#One"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.One" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.mean.Mean" title="pyGPs.Core.mean.Mean"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.mean.Mean</span></tt></a></p>
<p>One mean.</p>
<dl class="method">
<dt id="pyGPs.Core.mean.One.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#One.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.One.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.mean.One.getMean">
<tt class="descname">getMean</tt><big>(</big><em>x=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#One.getMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.One.getMean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.mean.PowerOfMean">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.mean.</tt><tt class="descname">PowerOfMean</tt><big>(</big><em>mean</em>, <em>d</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#PowerOfMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.PowerOfMean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.mean.Mean" title="pyGPs.Core.mean.Mean"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.mean.Mean</span></tt></a></p>
<p>Power of a mean fucntion.</p>
<dl class="method">
<dt id="pyGPs.Core.mean.PowerOfMean.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#PowerOfMean.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.PowerOfMean.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.mean.PowerOfMean.getMean">
<tt class="descname">getMean</tt><big>(</big><em>x=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#PowerOfMean.getMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.PowerOfMean.getMean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyGPs.Core.mean.PowerOfMean.hyp">
<tt class="descname">hyp</tt><a class="headerlink" href="#pyGPs.Core.mean.PowerOfMean.hyp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.mean.ProductOfMean">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.mean.</tt><tt class="descname">ProductOfMean</tt><big>(</big><em>mean1</em>, <em>mean2</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#ProductOfMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.ProductOfMean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.mean.Mean" title="pyGPs.Core.mean.Mean"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.mean.Mean</span></tt></a></p>
<p>Product of two mean fucntions.</p>
<dl class="method">
<dt id="pyGPs.Core.mean.ProductOfMean.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#ProductOfMean.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.ProductOfMean.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.mean.ProductOfMean.getMean">
<tt class="descname">getMean</tt><big>(</big><em>x=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#ProductOfMean.getMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.ProductOfMean.getMean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyGPs.Core.mean.ProductOfMean.hyp">
<tt class="descname">hyp</tt><a class="headerlink" href="#pyGPs.Core.mean.ProductOfMean.hyp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.mean.ScaleOfMean">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.mean.</tt><tt class="descname">ScaleOfMean</tt><big>(</big><em>mean</em>, <em>scalar</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#ScaleOfMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.ScaleOfMean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.mean.Mean" title="pyGPs.Core.mean.Mean"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.mean.Mean</span></tt></a></p>
<p>Scale of a mean function.</p>
<dl class="method">
<dt id="pyGPs.Core.mean.ScaleOfMean.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#ScaleOfMean.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.ScaleOfMean.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.mean.ScaleOfMean.getMean">
<tt class="descname">getMean</tt><big>(</big><em>x=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#ScaleOfMean.getMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.ScaleOfMean.getMean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyGPs.Core.mean.ScaleOfMean.hyp">
<tt class="descname">hyp</tt><a class="headerlink" href="#pyGPs.Core.mean.ScaleOfMean.hyp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.mean.SumOfMean">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.mean.</tt><tt class="descname">SumOfMean</tt><big>(</big><em>mean1</em>, <em>mean2</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#SumOfMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.SumOfMean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.mean.Mean" title="pyGPs.Core.mean.Mean"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.mean.Mean</span></tt></a></p>
<p>Sum of two mean functions.</p>
<dl class="method">
<dt id="pyGPs.Core.mean.SumOfMean.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#SumOfMean.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.SumOfMean.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.mean.SumOfMean.getMean">
<tt class="descname">getMean</tt><big>(</big><em>x=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#SumOfMean.getMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.SumOfMean.getMean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyGPs.Core.mean.SumOfMean.hyp">
<tt class="descname">hyp</tt><a class="headerlink" href="#pyGPs.Core.mean.SumOfMean.hyp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.mean.Zero">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.mean.</tt><tt class="descname">Zero</tt><a class="reference internal" href="_modules/pyGPs/Core/mean.html#Zero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.mean.Mean" title="pyGPs.Core.mean.Mean"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.mean.Mean</span></tt></a></p>
<p>Zero mean.</p>
<dl class="method">
<dt id="pyGPs.Core.mean.Zero.getDerMatrix">
<tt class="descname">getDerMatrix</tt><big>(</big><em>x=None</em>, <em>der=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#Zero.getDerMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.Zero.getDerMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyGPs.Core.mean.Zero.getMean">
<tt class="descname">getMean</tt><big>(</big><em>x=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/mean.html#Zero.getMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.mean.Zero.getMean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyGPs.Core.opt">
<span id="opt-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">opt</span></tt> Module<a class="headerlink" href="#module-pyGPs.Core.opt" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyGPs.Core.opt.BFGS">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.opt.</tt><tt class="descname">BFGS</tt><big>(</big><em>model</em>, <em>searchConfig=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/opt.html#BFGS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.opt.BFGS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.opt.Optimizer" title="pyGPs.Core.opt.Optimizer"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.opt.Optimizer</span></tt></a></p>
<p>quasi-Newton method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS)</p>
<dl class="method">
<dt id="pyGPs.Core.opt.BFGS.findMin">
<tt class="descname">findMin</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/opt.html#BFGS.findMin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.opt.BFGS.findMin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.opt.CG">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.opt.</tt><tt class="descname">CG</tt><big>(</big><em>model</em>, <em>searchConfig=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/opt.html#CG"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.opt.CG" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.opt.Optimizer" title="pyGPs.Core.opt.Optimizer"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.opt.Optimizer</span></tt></a></p>
<p>Conjugent gradient</p>
<dl class="method">
<dt id="pyGPs.Core.opt.CG.findMin">
<tt class="descname">findMin</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/opt.html#CG.findMin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.opt.CG.findMin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.opt.Minimize">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.opt.</tt><tt class="descname">Minimize</tt><big>(</big><em>model</em>, <em>searchConfig=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/opt.html#Minimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.opt.Minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.opt.Optimizer" title="pyGPs.Core.opt.Optimizer"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.opt.Optimizer</span></tt></a></p>
<p>minimize by Carl Rasmussen (python implementation of &#8220;minimize&#8221; in GPML)</p>
<dl class="method">
<dt id="pyGPs.Core.opt.Minimize.findMin">
<tt class="descname">findMin</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/opt.html#Minimize.findMin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.opt.Minimize.findMin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.opt.Optimizer">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.opt.</tt><tt class="descname">Optimizer</tt><big>(</big><em>model=None</em>, <em>searchConfig=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/opt.html#Optimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.opt.Optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="pyGPs.Core.opt.Optimizer.findMin">
<tt class="descname">findMin</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#pyGPs.Core.opt.Optimizer.findMin" title="Permalink to this definition">¶</a></dt>
<dd><p>Find minimal value based on negative-log-marginal-likelihood. 
optimalHyp, funcValue = findMin(x, y)</p>
<p>where funcValue is the minimal negative-log-marginal-likelihood during optimization,
and optimalHyp is a flattened numpy array 
(in sequence of meanfunc.hyp, covfunc.hyp, likfunc.hyp) 
of the hyparameters to achieve such value.</p>
<p>You can achieve advanced search strategy by initializing Optimizer with searchConfig, 
which is an instance of pyGPs.Optimization.conf. 
See more in pyGPs.Optimization.conf and pyGPs.Core.gp.GP.setOptimizer,
as well as in online documentation of section Optimizers.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyGPs.Core.opt.SCG">
<em class="property">class </em><tt class="descclassname">pyGPs.Core.opt.</tt><tt class="descname">SCG</tt><big>(</big><em>model</em>, <em>searchConfig=None</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/opt.html#SCG"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.opt.SCG" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyGPs.Core.opt.Optimizer" title="pyGPs.Core.opt.Optimizer"><tt class="xref py py-class docutils literal"><span class="pre">pyGPs.Core.opt.Optimizer</span></tt></a></p>
<p>Scaled conjugent gradient (faster than CG)</p>
<dl class="method">
<dt id="pyGPs.Core.opt.SCG.findMin">
<tt class="descname">findMin</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/opt.html#SCG.findMin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.opt.SCG.findMin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyGPs.Core.tools">
<span id="tools-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">tools</span></tt> Module<a class="headerlink" href="#module-pyGPs.Core.tools" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyGPs.Core.tools.brentmin">
<tt class="descclassname">pyGPs.Core.tools.</tt><tt class="descname">brentmin</tt><big>(</big><em>xlow</em>, <em>xupp</em>, <em>Nitmax</em>, <em>tol</em>, <em>f</em>, <em>nout=None</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/tools.html#brentmin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.tools.brentmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Brent&#8217;s minimization method in one dimension. 
Given a function f, and given a search interval this routine isolates 
the minimum of fractional precision of about tol using Brent&#8217;s method.
Reference: Section 10.2 Parabolic Interpolation and Brent&#8217;s Method in One Dimension
Press, Teukolsky, Vetterling &amp; Flannery
Numerical Recipes in C, Cambridge University Press, 2002
This is a python implementation of gpml functionality (Copyright (c) by
Hannes Nickisch 2010-01-10). 
xmin,fmin,funccout,varargout = BRENTMIN(xlow,xupp,Nit,tol,f,nout,varargin)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xlow</strong> &#8211; lower bound. i.e. search interval such that xlow&lt;=xmin&lt;=xupp</li>
<li><strong>xupp</strong> &#8211; uppper bound. i.e. search interval such that xlow&lt;=xmin&lt;=xupp</li>
<li><strong>Nitmax</strong> &#8211; maximum number of function evaluations made by the routine</li>
<li><strong>tol</strong> &#8211; fractional precision</li>
<li><strong>f</strong> &#8211; [y,varargout{:}] = f(x,varargin{:}) is the function</li>
<li><strong>nout</strong> &#8211; no. of outputs of f (in varargout) in addition to the y value</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">fmin is minimal function value. xmin is corresponding abscissa-value</p>
</td>
</tr>
</tbody>
</table>
<p>funccount is the number of function evaluations made. varargout is additional outputs of f at optimum.</p>
</dd></dl>

<dl class="function">
<dt id="pyGPs.Core.tools.cholupdate">
<tt class="descclassname">pyGPs.Core.tools.</tt><tt class="descname">cholupdate</tt><big>(</big><em>R</em>, <em>x</em>, <em>sgn='+'</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/tools.html#cholupdate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.tools.cholupdate" title="Permalink to this definition">¶</a></dt>
<dd><p>Placeholder for a python version of MATLAB&#8217;s cholupdate.  Now it is O(n^3)</p>
</dd></dl>

<dl class="function">
<dt id="pyGPs.Core.tools.solve_chol">
<tt class="descclassname">pyGPs.Core.tools.</tt><tt class="descname">solve_chol</tt><big>(</big><em>L</em>, <em>B</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/tools.html#solve_chol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.tools.solve_chol" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve linear equations from the Cholesky factorization.
Solve A*X = B for X, where A is square, symmetric, positive definite. The
input to the function is R the Cholesky decomposition of A and the matrix B.
Example: X = solve_chol(chol(A),B);</p>
</dd></dl>

<dl class="function">
<dt id="pyGPs.Core.tools.unique">
<tt class="descclassname">pyGPs.Core.tools.</tt><tt class="descname">unique</tt><big>(</big><em>x</em><big>)</big><a class="reference internal" href="_modules/pyGPs/Core/tools.html#unique"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyGPs.Core.tools.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list with unique elements.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Core Package</a><ul>
<li><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">Core</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-pyGPs.Core.cov"><tt class="docutils literal"><span class="pre">cov</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyGPs.Core.gp"><tt class="docutils literal"><span class="pre">gp</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyGPs.Core.inf"><tt class="docutils literal"><span class="pre">inf</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyGPs.Core.lik"><tt class="docutils literal"><span class="pre">lik</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyGPs.Core.mean"><tt class="docutils literal"><span class="pre">mean</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyGPs.Core.opt"><tt class="docutils literal"><span class="pre">opt</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pyGPs.Core.tools"><tt class="docutils literal"><span class="pre">tools</span></tt> Module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pyGPs.html"
                        title="previous chapter">pyGPs Package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pyGPs.GraphExtensions.html"
                        title="next chapter">GraphExtensions Package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/pyGPs.Core.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyGPs.GraphExtensions.html" title="GraphExtensions Package"
             >next</a> |</li>
        <li class="right" >
          <a href="pyGPs.html" title="pyGPs Package"
             >previous</a> |</li>
        <li><a href="index.html">pyGPs v1.2 documentation</a> &raquo;</li>
          <li><a href="modules.html" >pyGPs</a> &raquo;</li>
          <li><a href="pyGPs.html" >pyGPs Package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Marion Neumann, Shan Huang, Daniel Marthaler, Kristian Kersting.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>